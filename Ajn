--[[
Mobile-first Monolithic Blade Ball Script (GUI + Core)
- Single file: Auto Parry (curve + accuracy), Auto Spam, Manual Spam
- UI forced to PlayerGui so it shows on mobile executors
- Touch buttons included for Parry, Hold-Spam, Toggle AutoSpam
- Same UI colors / style as requested (dark panel, purple slider fill, green/red toggles)
- Paste into your executor and run AFTER game loads (repeat until game:IsLoaded if needed)
--]]

-- wait until game loaded (safe for paste-run)
repeat task.wait() until game:IsLoaded()

-- ====== CONFIG ======
local CONFIG = {
    ParryHotkey = Enum.KeyCode.Q,          -- still available if you use keyboard
    ManualSpamHotkey = Enum.KeyCode.G,
    ToggleAutoSpamHotkey = Enum.KeyCode.H,
    GuiToggleKey = Enum.KeyCode.F1,
    GuiPosition = UDim2.new(0.01,0,0.12,0)
}

-- ====== SERVICES ======
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace:FindFirstChildOfClass("Camera") or workspace.CurrentCamera

-- ====== PATHS & REMOTES (autodetect common names) ======
local function findInReplicated(name)
    local r = ReplicatedStorage:FindFirstChild(name)
    if r then return r end
    local container = ReplicatedStorage:FindFirstChild("Remotes")
    if container then return container:FindFirstChild(name) end
    return nil
end

local REMOTE_NAMES = {
    "ParryAttempt", "ParryAttemptAll", "ParrySuccess", "ParrySuccessAll", "UnParry",
    "getParryAmt", "SetParryType", "NoobParryHappened", "Clash", "Attack", "Ability"
}
local Remotes = {}
for _, name in ipairs(REMOTE_NAMES) do
    Remotes[name] = findInReplicated(name)
end

-- find Balls folder (common)
local function findBallsFolder()
    local candidates = {"Balls", "Ball", "balls"}
    for _, n in ipairs(candidates) do
        local f = workspace:FindFirstChild(n)
        if f then return f end
    end
    return workspace
end
local BallsFolder = findBallsFolder()

-- ====== GLOBAL STATE ======
getgenv().BB = getgenv().BB or {}
local BB = getgenv().BB
BB.settings = BB.settings or {
    enabledAutoParry = false,
    enabledAutoSpam = false,
    enabledManualSpam = false,
    parryAccuracy = 75,
    parryDistance = 35,
    spamMode = "Remote",
    parryMode = "Remote",
    curveMode = "None",
    cameraBackwards = false,
    spamInterval = 0.09,
    manualSpamInterval = 0.08,
    playParryAnimation = true,
    autoParryHoldTime = 0.12,
    log = false
}

local function log(...)
    if BB.settings.log then
        print("[BB]", ...)
    end
end

-- ====== UTIL: balls & prediction ======
local function getAliveBalls()
    local alive = BallsFolder:FindFirstChild("Alive") or BallsFolder:FindFirstChild("alive")
    if alive and #alive:GetChildren() > 0 then
        return alive:GetChildren()
    end
    local res = {}
    for _, c in pairs(BallsFolder:GetDescendants()) do
        if c:IsA("BasePart") and (c.Name:lower():find("ball") or c.Parent and c.Parent.Name:lower():find("ball")) then
            table.insert(res, c)
        end
    end
    -- fallback: return top-level BaseParts
    if #res == 0 then
        for _, c in pairs(BallsFolder:GetChildren()) do
            if c:IsA("BasePart") then table.insert(res, c) end
            if c:IsA("Model") then
                local p = c:FindFirstChildWhichIsA("BasePart") or c.PrimaryPart
                if p then table.insert(res, p) end
            end
        end
    end
    return res
end

local function estimateTimeToPlayer(ballPart, playerRoot)
    if not ballPart or not playerRoot or not ballPart:IsA("BasePart") or not playerRoot:IsA("BasePart") then return math.huge end
    local posB, vel, posP = ballPart.Position, ballPart.Velocity or Vector3.new(), playerRoot.Position
    local rel = posP - posB
    local speed = vel.Magnitude
    if speed <= 0.01 then return math.huge end
    local proj = rel:Dot(vel.Unit)
    if proj <= 0 then return math.huge end
    return proj / speed
end

-- ====== CURVE & ACCURACY ======
local function computeCurveOffset(mode)
    mode = mode or BB.settings.curveMode
    if mode == "None" then return 0 end
    if mode == "Camera" then
        local cf = Camera.CFrame
        local pitch = math.asin(-cf.LookVector.Y)
        return (pitch - 0.5) * 0.03
    elseif mode == "Backwards" then
        return -0.03
    elseif mode == "Random" then
        return (math.random() - 0.5) * 0.06
    elseif mode == "Fast" then
        return 0.04
    elseif mode == "Slow" then
        return -0.04
    end
    return 0
end

local function computeAccuracyJitter(accuracy)
    accuracy = math.clamp(accuracy or 75, 1, 100)
    local maxJitter = 0.12
    local jitter = (1 - (accuracy / 100)) * maxJitter
    return (math.random() - 0.5) * jitter
end

-- ====== REMOTE HELPERS ======
local function safeFire(remote, ...)
    if not remote then return false end
    local ok = pcall(function()
        if typeof(remote) == "Instance" and remote.FireServer then
            remote:FireServer(...)
        elseif typeof(remote) == "Instance" and remote.fire then
            remote:fire(...)
        elseif typeof(remote) == "function" then
            remote(...)
        end
    end)
    return ok
end

local function doParryAttempt()
    if BB.settings.parryMode == "Remote" then
        if Remotes["ParryAttempt"] then return safeFire(Remotes["ParryAttempt"]) end
        if Remotes["ParryAttemptAll"] then return safeFire(Remotes["ParryAttemptAll"]) end
        if Remotes["ParrySuccess"] then return safeFire(Remotes["ParrySuccess"]) end
        if Remotes["Clash"] then return safeFire(Remotes["Clash"]) end
    else
        pcall(function()
            if getgenv().System and getgenv().System.parry and getgenv().System.parry.keypress then
                getgenv().System.parry.keypress()
            end
        end)
    end
    return false
end

local function doUnparry()
    if Remotes["UnParry"] then safeFire(Remotes["UnParry"]) end
end

local function doSpam()
    if BB.settings.spamMode == "Remote" then
        if Remotes["Clash"] then safeFire(Remotes["Clash"]); return end
        if Remotes["Attack"] then safeFire(Remotes["Attack"]); return end
        if Remotes["Ability"] then safeFire(Remotes["Ability"]); return end
        if Remotes["ParryAttempt"] then safeFire(Remotes["ParryAttempt"]); return end
    else
        pcall(function()
            if getgenv().System and getgenv().System.auto_spam and getgenv().System.auto_spam.keypress then
                getgenv().System.auto_spam.keypress()
            end
        end)
    end
end

-- ====== LOOPS: Auto Parry / Auto Spam / Manual Spam ======
local autoParryThread
local function startAutoParry()
    if autoParryThread then return end
    BB.settings.enabledAutoParry = true
    autoParryThread = task.spawn(function()
        while BB.settings.enabledAutoParry do
            local balls = getAliveBalls()
            local root = LocalPlayer.Character and (LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or LocalPlayer.Character:FindFirstChild("Torso"))
            if root and #balls > 0 then
                local bestTime, bestPart = math.huge, nil
                for _, b in pairs(balls) do
                    local part = (b:IsA("BasePart") and b) or (b:IsA("Model") and (b:FindFirstChildWhichIsA("BasePart") or b.PrimaryPart)) or nil
                    if part and part.Position and part.Velocity then
                        local t = estimateTimeToPlayer(part, root)
                        if t < bestTime then bestTime = t; bestPart = part end
                    end
                end
                if bestPart and bestTime < 0.6 then
                    local curveOffset = computeCurveOffset(BB.settings.curveMode)
                    local jitter = computeAccuracyJitter(BB.settings.parryAccuracy)
                    local triggerIn = bestTime - (0.06 + curveOffset + jitter)
                    if triggerIn <= 0 then
                        doParryAttempt()
                        delay(BB.settings.autoParryHoldTime + math.abs(jitter), function() doUnparry() end)
                        task.wait(0.06)
                    else
                        local scheduled = tick() + triggerIn
                        repeat
                            task.wait()
                        until tick() >= scheduled or not BB.settings.enabledAutoParry
                        if BB.settings.enabledAutoParry then
                            doParryAttempt()
                            delay(BB.settings.autoParryHoldTime + math.abs(jitter), function() doUnparry() end)
                        end
                    end
                end
            end
            RunService.Heartbeat:Wait()
        end
        autoParryThread = nil
    end)
end

local function stopAutoParry()
    BB.settings.enabledAutoParry = false
    autoParryThread = nil
end

local autoSpamThread
local function startAutoSpam()
    if autoSpamThread then return end
    BB.settings.enabledAutoSpam = true
    autoSpamThread = task.spawn(function()
        while BB.settings.enabledAutoSpam do
            doSpam()
            task.wait(math.max(0.02, BB.settings.spamInterval or 0.09))
        end
        autoSpamThread = nil
    end)
end

local function stopAutoSpam()
    BB.settings.enabledAutoSpam = false
    autoSpamThread = nil
end

local manualSpamActive = false
local function manualSpamLoop()
    while manualSpamActive do
        doSpam()
        task.wait(BB.settings.manualSpamInterval or 0.08)
    end
end

-- ====== INPUT: touch-friendly & keyboard (if available) ======
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard then
        local key = input.KeyCode
        if key == CONFIG.ParryHotkey then
            doParryAttempt(); delay(BB.settings.autoParryHoldTime or 0.12, doUnparry)
        elseif key == CONFIG.ManualSpamHotkey then
            if not manualSpamActive then manualSpamActive = true; task.spawn(manualSpamLoop) end
        elseif key == CONFIG.ToggleAutoSpamHotkey then
            BB.settings.enabledAutoSpam = not BB.settings.enabledAutoSpam
            if BB.settings.enabledAutoSpam then startAutoSpam() else stopAutoSpam() end
        elseif key == CONFIG.GuiToggleKey then
            if guiRoot and guiRoot.Enabled ~= nil then guiRoot.Enabled = not guiRoot.Enabled end
        end
    end
end)
UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == CONFIG.ManualSpamHotkey then manualSpamActive = false end
    end
end)

-- ====== GUI: forced to PlayerGui, mobile-first layout ======
local playerGui = LocalPlayer:WaitForChild("PlayerGui")
local guiRoot = Instance.new("ScreenGui")
guiRoot.Name = "BB_SingleTab_UI_Mobile"
guiRoot.ResetOnSpawn = false
guiRoot.DisplayOrder = 999
guiRoot.Parent = playerGui

local mainFrame = Instance.new("Frame")
mainFrame.Name = "Main"
mainFrame.Size = UDim2.new(0, 420, 0, 360)
mainFrame.Position = CONFIG.GuiPosition
mainFrame.BackgroundColor3 = Color3.fromRGB(35,35,35)
mainFrame.BackgroundTransparency = 0.12
mainFrame.BorderSizePixel = 0
mainFrame.Parent = guiRoot
mainFrame.Active = true
mainFrame.Draggable = true
Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0,8)

local title = Instance.new("TextLabel", mainFrame)
title.Size = UDim2.new(1, -12, 0, 36)
title.Position = UDim2.new(0,8,0,6)
title.BackgroundTransparency = 1
title.Text = "Blade Ball â€” Mobile Single Tab"
title.TextColor3 = Color3.fromRGB(240,240,240)
title.TextXAlignment = Enum.TextXAlignment.Left
title.Font = Enum.Font.GothamBold
title.TextSize = 16

-- helper: create toggle row
local function createToggle(labelText, initial, posY, callback)
    local lbl = Instance.new("TextLabel", mainFrame)
    lbl.Size = UDim2.new(0.6, -16, 0, 28)
    lbl.Position = UDim2.new(0, 12, 0, posY)
    lbl.BackgroundTransparency = 1
    lbl.Text = labelText
    lbl.TextColor3 = Color3.fromRGB(220,220,220)
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 14

    local btn = Instance.new("TextButton", mainFrame)
    btn.Size = UDim2.new(0, 86, 0, 28)
    btn.Position = UDim2.new(0.7, 0, 0, posY)
    btn.Text = initial and "ON" or "OFF"
    btn.Font = Enum.Font.GothamSemibold
    btn.TextSize = 13
    btn.TextColor3 = initial and Color3.fromRGB(40,220,40) or Color3.fromRGB(230,80,80)
    btn.BackgroundColor3 = Color3.fromRGB(40,40,40)
    btn.AutoButtonColor = true
    btn.MouseButton1Click:Connect(function()
        local now = not (btn.Text == "ON")
        btn.Text = now and "ON" or "OFF"
        btn.TextColor3 = now and Color3.fromRGB(40,220,40) or Color3.fromRGB(230,80,80)
        pcall(callback, now)
    end)
    return {label = lbl, button = btn}
end

-- helper: slider
local function createSlider(labelText, init, min, max, posY, callback)
    local lbl = Instance.new("TextLabel", mainFrame)
    lbl.Size = UDim2.new(0.7, -16, 0, 20)
    lbl.Position = UDim2.new(0, 12, 0, posY)
    lbl.BackgroundTransparency = 1
    lbl.Text = labelText .. " : " .. tostring(init)
    lbl.TextColor3 = Color3.fromRGB(220,220,220)
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 13

    local bar = Instance.new("Frame", mainFrame)
    bar.Size = UDim2.new(0.9, -24, 0, 12)
    bar.Position = UDim2.new(0.05, 0, 0, posY + 22)
    bar.BackgroundColor3 = Color3.fromRGB(50,50,50)
    bar.BorderSizePixel = 0
    Instance.new("UICorner", bar).CornerRadius = UDim.new(0,6)

    local fill = Instance.new("Frame", bar)
    fill.Size = UDim2.new((init - min) / (max - min), 0, 1, 0)
    Instance.new("UICorner", fill).CornerRadius = UDim.new(0,6)
    fill.BackgroundColor3 = Color3.fromRGB(170,80,240)

    local dragging = false
    bar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = true end
    end)
    bar.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement) then
            local mouse = UserInputService:GetMouseLocation()
            local absPos = bar.AbsolutePosition
            local rel = math.clamp((mouse.X - absPos.X) / bar.AbsoluteSize.X, 0, 1)
            fill.Size = UDim2.new(rel, 0, 1, 0)
            local value = math.floor(min + (max - min) * rel + 0.5)
            lbl.Text = labelText .. " : " .. tostring(value)
            pcall(callback, value)
        end
    end)
    return {label = lbl, bar = bar, fill = fill}
end

-- build UI rows
local y = 44
local autop = createToggle("Auto Parry", BB.settings.enabledAutoParry, y, function(on)
    BB.settings.enabledAutoParry = on
    if on then startAutoParry() else stopAutoParry() end
end); y = y + 36

local autospam = createToggle("Auto Spam", BB.settings.enabledAutoSpam, y, function(on)
    BB.settings.enabledAutoSpam = on
    if on then startAutoSpam() else stopAutoSpam() end
end); y = y + 36

local manual = createToggle("Manual Spam (hold)", BB.settings.enabledManualSpam, y, function(on)
    BB.settings.enabledManualSpam = on
end); y = y + 36

local accSlider = createSlider("Parry Accuracy (1-100)", BB.settings.parryAccuracy, 1, 100, y, function(v) BB.settings.parryAccuracy = v end); y = y + 54

-- curve dropdown (cycle)
local curveBox = Instance.new("TextLabel", mainFrame)
curveBox.Size = UDim2.new(0.55, 0, 0, 22)
curveBox.Position = UDim2.new(0, 12, 0, y)
curveBox.BackgroundTransparency = 1
curveBox.Text = "Curve: " .. BB.settings.curveMode
curveBox.TextColor3 = Color3.fromRGB(220,220,220)
curveBox.Font = Enum.Font.Gotham
curveBox.TextSize = 13

local curveBtn = Instance.new("TextButton", mainFrame)
curveBtn.Size = UDim2.new(0, 120, 0, 22)
curveBtn.Position = UDim2.new(0.6, 0, 0, y)
curveBtn.Text = "Change Curve"
curveBtn.Font = Enum.Font.GothamSemibold
curveBtn.TextSize = 13
curveBtn.BackgroundColor3 = Color3.fromRGB(45,45,45)
curveBtn.AutoButtonColor = true

local curveOptions = {"None","Camera","Backwards","Random","Fast","Slow"}
curveBtn.MouseButton1Click:Connect(function()
    local idx = table.find(curveOptions, BB.settings.curveMode) or 1
    idx = idx + 1
    if idx > #curveOptions then idx = 1 end
    BB.settings.curveMode = curveOptions[idx]
    curveBox.Text = "Curve: " .. BB.settings.curveMode
end)
y = y + 34

-- camera backwards quick toggle
local camLbl = Instance.new("TextLabel", mainFrame)
camLbl.Size = UDim2.new(0.6, -16, 0, 22)
camLbl.Position = UDim2.new(0, 12, 0, y)
camLbl.BackgroundTransparency = 1
camLbl.Text = "Camera Backwards (flip)"
camLbl.TextColor3 = Color3.fromRGB(220,220,220)
camLbl.Font = Enum.Font.Gotham
camLbl.TextSize = 13

local camBtn = Instance.new("TextButton", mainFrame)
camBtn.Size = UDim2.new(0, 86, 0, 22)
camBtn.Position = UDim2.new(0.7, 0, 0, y)
camBtn.Text = BB.settings.cameraBackwards and "ON" or "OFF"
camBtn.TextColor3 = BB.settings.cameraBackwards and Color3.fromRGB(40,220,40) or Color3.fromRGB(220,60,60)
camBtn.Font = Enum.Font.GothamSemibold
camBtn.TextSize = 13
camBtn.BackgroundColor3 = Color3.fromRGB(45,45,45)
camBtn.AutoButtonColor = true

camBtn.MouseButton1Click:Connect(function()
    BB.settings.cameraBackwards = not BB.settings.cameraBackwards
    camBtn.Text = BB.settings.cameraBackwards and "ON" or "OFF"
    camBtn.TextColor3 = BB.settings.cameraBackwards and Color3.fromRGB(40,220,40) or Color3.fromRGB(220,60,60)
    if BB.settings.cameraBackwards and Camera and Camera.CFrame then
        local cf = Camera.CFrame
        Camera.CFrame = CFrame.new(cf.Position) * (cf - cf.Position) * CFrame.Angles(0, math.pi, 0)
    end
end)
y = y + 36

-- spam mode toggle button
local spamLbl = Instance.new("TextLabel", mainFrame)
spamLbl.Size = UDim2.new(0.6, -16, 0, 22)
spamLbl.Position = UDim2.new(0, 12, 0, y)
spamLbl.BackgroundTransparency = 1
spamLbl.Text = "Auto Spam Mode: " .. BB.settings.spamMode
spamLbl.TextColor3 = Color3.fromRGB(220,220,220)
spamLbl.Font = Enum.Font.Gotham
spamLbl.TextSize = 13

local spamBtn = Instance.new("TextButton", mainFrame)
spamBtn.Size = UDim2.new(0, 120, 0, 22)
spamBtn.Position = UDim2.new(0.6, 0, 0, y)
spamBtn.Text = "Toggle Mode"
spamBtn.Font = Enum.Font.GothamSemibold
spamBtn.TextSize = 13
spamBtn.BackgroundColor3 = Color3.fromRGB(45,45,45)
spamBtn.AutoButtonColor = true

spamBtn.MouseButton1Click:Connect(function()
    BB.settings.spamMode = (BB.settings.spamMode == "Remote") and "Keypress" or "Remote"
    spamLbl.Text = "Auto Spam Mode: " .. BB.settings.spamMode
end)
y = y + 38

local hint = Instance.new("TextLabel", mainFrame)
hint.Size = UDim2.new(1, -20, 0, 40)
hint.Position = UDim2.new(0, 10, 1, -56)
hint.BackgroundTransparency = 1
hint.Text = ("Touch buttons below. Keys still work with keyboard if available.")
hint.TextColor3 = Color3.fromRGB(200,200,200)
hint.Font = Enum.Font.Gotham
hint.TextSize = 12
hint.TextWrapped = true
hint.TextXAlignment = Enum.TextXAlignment.Left

local watermark = Instance.new("TextLabel", mainFrame)
watermark.Size = UDim2.new(0, 220, 0, 14)
watermark.Position = UDim2.new(0, 12, 1, -22)
watermark.BackgroundTransparency = 1
watermark.Text = "Single-Tab Mobile Script"
watermark.TextColor3 = Color3.fromRGB(150,150,150)
watermark.Font = Enum.Font.Gotham
watermark.TextSize = 10
watermark.TextXAlignment = Enum.TextXAlignment.Left

-- ====== TOUCH BUTTONS (big, obvious) ======
local touchParry = Instance.new("TextButton", mainFrame)
touchParry.Size = UDim2.new(0, 100, 0, 42)
touchParry.Position = UDim2.new(0.02, 0, 0.78, 0)
touchParry.Text = "PARRY"
touchParry.Font = Enum.Font.GothamBold
touchParry.TextSize = 18
touchParry.BackgroundColor3 = Color3.fromRGB(55,55,55)
Instance.new("UICorner", touchParry).CornerRadius = UDim.new(0,6)
touchParry.TextColor3 = Color3.fromRGB(240,240,240)

touchParry.MouseButton1Click:Connect(function()
    doParryAttempt()
    delay(BB.settings.autoParryHoldTime or 0.12, doUnparry)
end)

local touchManual = Instance.new("TextButton", mainFrame)
touchManual.Size = UDim2.new(0, 140, 0, 42)
touchManual.Position = UDim2.new(0.28, 0, 0.78, 0)
touchManual.Text = "HOLD SPAM"
touchManual.Font = Enum.Font.GothamBold
touchManual.TextSize = 16
touchManual.BackgroundColor3 = Color3.fromRGB(55,55,55)
Instance.new("UICorner", touchManual).CornerRadius = UDim.new(0,6)
touchManual.TextColor3 = Color3.fromRGB(240,240,240)

touchManual.InputBegan:Connect(function(i)
    if i.UserInputType == Enum.UserInputType.Touch or i.UserInputType == Enum.UserInputType.MouseButton1 then
        manualSpamActive = true
        task.spawn(manualSpamLoop)
    end
end)
touchManual.InputEnded:Connect(function(i)
    if i.UserInputType == Enum.UserInputType.Touch or i.UserInputType == Enum.UserInputType.MouseButton1 then
        manualSpamActive = false
    end
end)

local touchToggleSpam = Instance.new("TextButton", mainFrame)
touchToggleSpam.Size = UDim2.new(0, 120, 0, 34)
touchToggleSpam.Position = UDim2.new(0.66, 0, 0.78, 0)
touchToggleSpam.Text = BB.settings.enabledAutoSpam and "AutoSpam: ON" or "AutoSpam: OFF"
touchToggleSpam.Font = Enum.Font.GothamSemibold
touchToggleSpam.TextSize = 14
touchToggleSpam.BackgroundColor3 = Color3.fromRGB(45,45,45)
Instance.new("UICorner", touchToggleSpam).CornerRadius = UDim.new(0,6)
touchToggleSpam.TextColor3 = BB.settings.enabledAutoSpam and Color3.fromRGB(40,220,40) or Color3.fromRGB(230,80,80)
touchToggleSpam.MouseButton1Click:Connect(function()
    BB.settings.enabledAutoSpam = not BB.settings.enabledAutoSpam
    if BB.settings.enabledAutoSpam then
        startAutoSpam()
        touchToggleSpam.Text = "AutoSpam: ON"
        touchToggleSpam.TextColor3 = Color3.fromRGB(40,220,40)
    else
        stopAutoSpam()
        touchToggleSpam.Text = "AutoSpam: OFF"
        touchToggleSpam.TextColor3 = Color3.fromRGB(230,80,80)
    end
end)

-- ====== INITIAL SYNC ======
if BB.settings.enabledAutoParry then startAutoParry() end
if BB.settings.enabledAutoSpam then startAutoSpam() end

LocalPlayer.CharacterRemoving:Connect(function()
    BB.settings.enabledAutoParry = false
    BB.settings.enabledAutoSpam = false
    manualSpamActive = false
end)

print("[BB] Mobile single-file script loaded. Touch buttons available on the UI.")
